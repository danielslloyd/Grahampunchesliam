<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Graham Throws Veggies at Liam</title>
    <style>* { padding: 0; margin: 0; } canvas { background: #eee; display: block; margin: 0 auto; }</style>
</head>
<body>

<canvas id="myCanvas" width="680" height="420"></canvas>

<script>
	"use strict";
    //FIXED bug when first base dies: old bugs are fine, new bugs freak out
	//BUG if you place a turret before the first well
	
	var canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext("2d");
	canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    var liamRadius = 7;
	var punchRadius = 10;  // Collision radius for veggies
	var fridgeWidth = 20;  // Renamed from wellWidth
    var liamSpeed = 4;
    var punchSpeed = 12;
	var veggieSize = 20;  // Size of veggie sprites
	var veggieSprites = ['ðŸ¥•', 'ðŸ¥¦', 'ðŸŒ½', 'ðŸ…', 'ðŸ¥’', 'ðŸ§„', 'ðŸ§…', 'ðŸ¥¬', 'ðŸ«‘', 'ðŸ†'];  // Veggie emojis
    //var x = canvas.width/2;
    //var y = canvas.height-30;
    //var dx = 2;
    //var dy = -2;
    //var rightPressed = false;
    //var leftPressed = false;
    var maxScore = 1000;
    var grahamWidth = 15;  // Renamed from turretWidth
    var railWidth = 5;
	var fireLoops = 2;
	var minLiamGen = 1;				// Liams will never come more than every __ frames
	var initLiamGen = 10;			// At game start, Liams come every __ frames
	var stepLiamGen = 1100;			// Liam frequency increases every __ frames
	
	var nearBuildingX = 0;
	var nearBuildingY = 0;
	var nearDist =0;

	var deadLiamBuffer = 500;
	var grahamCost = 300;  // Cost in XP
	var fridgeHealth = 100;  // Renamed from wellHealth
	var grahamRange = 160;
	var grahamFiringArc = 90;  // Wedge angle in degrees
	var grahamReloadTime = 5;  // Base reload time
	var deathPushParam = 3;
	//var wellPullParam = 50;
	var minPullPushRatio = 1.03;
	var ovr1Range = 200;
	var fridgePullLinearMod = .001;  // Renamed from wellPullLinearMod
	
	var pathCalcStep = 5;  // Liams re-evaluate path every __ frames
	var grahamGranularity = 5;
	var grahamSeekAggro = 1.8; // other spot on rail must be __x better to move graham
	var grahamSpeed = 6;

	var fridgeSeekAggro = .8;  // Renamed from wellSeekAggro

	var fridgeRadius = 30;  // Renamed from wellRadius
	var fridgeCost = 1000;  // Cost in XP
	var fridgeMilkOz = 100;  // Starting milk in ounces
	var milkPerEmoji = 10;  // 10 oz = 1 milk carton emoji

	var portalRadius = 50;  // Radius of cloning portals
	var portalSpawnRate = 600;  // Frames between portal spawns
	var maxPortals = 3;  // Maximum number of portals on map

	var elbowRoom = 0;
	var minDistance = 50;
	var selectedGraham = -1; // Currently selected Graham for rotation
	var grahamNextId = 1; // Auto-incrementing ID for Grahams
	
	var terrain = [];
	var terrainRes = 10;
	var terrainX=0;
	var terrainY=0;
	var trendStrength = .25;
	var maxE = 2;

    var score = 0;
	var liams = [];  // Renamed from bugs
	var minLiveLiam = 0;
	var liamTotalCount = 0;
	var liamLiveCount = 0;
	var liamGenCount = 0;
	var liamGenTimer = 0;
	var liamsOn = false;
	var punches = [];  // Actually veggies now!
	var punchCount = 0;
	var fridges = [];  // Renamed from wells - but now we only have ONE in center
	var grahams = [];  // Renamed from turrets
	var grahamCount = 0;
	var floatingTexts = [];  // For +100 XP animations
	var killLog = [];  // Kill log messages
	var portals = [];  // Cloning portals
	var portalSpawnCounter = 0;  // Counter for portal spawning

	var frameCounter = 0;
	var timr = [0,0,0,0,0,0,0,0,0,0];
	var xp = 0;  // Renamed from money - earned by stopping Liams
	var proposedCost = 0;
	var currentPos = [];
	var minLivePunch = 0;
	var kShift = false;
	var gPlace = false;  // Renamed from tPlace (Graham placement)
	var wPlace = false;
	var isDragging = false;
	var dragDist = 0;
	var startingPos = [];
	var clickDown=false;
	var valid = false;
	var paused = false;
	
	var wellView = false;
	var turretView = false;
	var resourceView = false;
	var infoView = false;
	
	

    document.addEventListener("mousemove", msMv, false);
    document.addEventListener("mousedown", msDn, false);
    document.addEventListener("mouseup", msUp, false);
    document.addEventListener("keydown", keyDn, false);
    document.addEventListener("keyup", keyUp, false);
	
	function msDn(e) {
		startingPos=[e.clientX-canvas.offsetLeft,e.clientY-canvas.offsetTop];
		clickDown=true;
		//if (dist(wells[0].x,wells[0].y,startingPos[0],startingPos[1])>=wellRadius) {}
	}
	function keyDn(e) {
		var keyCode = e.which || e.keyCode;
		switch (keyCode) {
		case 16:
			kShift=true;
		break;
		}
		
	}
	function keyUp(e) {
		var keyCode = e.which || e.keyCode;
		switch (keyCode) {
		case 16:
			kShift=false;
		break;
		case 71:  // G key for Graham placement
			gPlace=!gPlace;
		break;
		case 32:  // Spacebar to pause
			paused=!paused;
		break;
		case 37:  // Left arrow - rotate selected Graham left
			if (selectedGraham >= 0 && selectedGraham < grahams.length) {
				grahams[selectedGraham].angle -= Math.PI / 18;  // Rotate 10 degrees left
			}
		break;
		case 39:  // Right arrow - rotate selected Graham right
			if (selectedGraham >= 0 && selectedGraham < grahams.length) {
				grahams[selectedGraham].angle += Math.PI / 18;  // Rotate 10 degrees right
			}
		break;
		case 67:  // C key - Upgrade caffeine level for selected Graham
			if (selectedGraham >= 0 && selectedGraham < grahams.length) {
				var g = grahams[selectedGraham];
				var upgradeCost = (g.caffeineLevel + 1) * 200;  // Cost increases with level
				if (g.xp >= upgradeCost) {
					g.xp -= upgradeCost;
					g.caffeineLevel++;
					// Add floating text notification
					floatingTexts.push({
						x: g.x,
						y: g.y - 35,
						text: "CAFFEINE +1!",
						frame: 0,
						maxFrames: 60
					});
				}
			}
		break;
		}

	}
	function msMv(e) {
		if (clickDown) {
			dragDist = dist(startingPos[0],startingPos[1],e.clientX,e.clientY);
			if (dragDist>=10){
				isDragging = true; //***********************
			}
			else {
				isDragging = false;
			}
		}
		currentPos = [e.clientX-canvas.offsetLeft,e.clientY-canvas.offsetTop]
    }
	function msUp(e) {
		currentPos = [e.clientX-canvas.offsetLeft,e.clientY-canvas.offsetTop]
		var cost = costEstimate();
		if (xp >= cost && nearDist>=elbowRoom) {
			elbowRoom = minDistance;
			if (gPlace) {
				makeGraham(currentPos[0],currentPos[1],0,0,0,0);
				xp-=cost;
				// Auto-select the newly placed Graham
				selectedGraham = grahams.length - 1;
				gPlace = false;  // Exit placement mode
			}
			// No fridge placement - fridge is auto-created in center
			isDragging=false;
			clickDown=false;
			startingPos = [];
			dragDist = 0;
		}
		// Check if clicking on existing Graham to select it
		if (!gPlace && !wPlace) {
			var i = 0;
			var l = grahams.length;
			for(i=0; i<l; i++) {
				if (dist(currentPos[0], currentPos[1], grahams[i].x, grahams[i].y) <= grahamWidth) {
					selectedGraham = i;
					return;
				}
			}
			selectedGraham = -1;  // Deselect if clicking elsewhere
		}
	}
				
	//function clickHandler(e) {
	//	if (money>=turretCost) {
	//		makeTurret(e.clientX -canvas.offsetLeft,e.clientY- canvas.offsetTop);
	//		money-=turretCost;
	//	}
    //}
	function fridgePull(i) {
		liams[i].wPullx=0;
		liams[i].wPully=0;
		var j=0;
		var l = fridges.length;
		var firstJ = true;
		var dst = 0;
		if (fridges[liams[i].closestFridge].status ==1) {
		dst = dist(liams[i].x,liams[i].y,fridges[liams[i].closestFridge].x,fridges[liams[i].closestFridge].y);
		liams[i].closestFridgeDst=dst;
		}
		else {
		liams[i].closestFridgeDst=canvas.width*50;
		}
		for(j=0; j<l; j++) {

			if (fridges[j].status ==1) {
				dst = dist(liams[i].x,liams[i].y,fridges[j].x,fridges[j].y);
				if (dst<liams[i].closestFridgeDst*fridgeSeekAggro) {
					liams[i].closestFridge=j
					liams[i].closestFridgeDst=dst
				}
				liams[i].wPullx += (fridgePullLinearMod)*(fridges[j].x-liams[i].x)/(dst)+(fridges[j].x-liams[i].x)/(dst*dst);
				liams[i].wPully += (fridgePullLinearMod)*(fridges[j].y-liams[i].y)/(dst)+(fridges[j].y-liams[i].y)/(dst*dst);
			}
		}
		liams[i].wPullx *= 1+liamLiveCount/700;
		liams[i].wPully *= 1+liamLiveCount/700;
	}
	//function wellPully(i) {
	//	var bPully=0;
	//	var j=0;
	//	var l = wells.length;
	//	for(j=0; j<l; j++) {
	//		var dst = dist(bugs[i].x,bugs[i].y,wells[j].x,wells[j].y);
	//		bPully += (wellPullLinearMod)*(wells[j].y-bugs[i].y)/(dst)+(wells[j].y-bugs[i].y)/(dst*dst);
	//		bPully *= 1+bugLiveCount/700;
	//	}
	//	return bPully;
	//}
	
	//function deathPushx(i) {
	//	var dPushx=0;
	//	var j=0;
	//	var l = bugs.length;
	//	for(j=0; j<l; j++) {
	//		if (bugs[j].status == 0 && i != j) {
	//			var dst = dist(bugs[i].x,bugs[i].y,bugs[j].x,bugs[j].y);
	//			dPushx -= (bugs[j].x-bugs[i].x)/(dst*dst);
	//		}
	//	}
	//	return dPushx;
	//}

	function deathPush(i) {
		liams[i].dPushy=0;
		liams[i].dPushx=0;
		var j=0;
		var l = liams.length;
		for(j=0; j<l; j++) {
			if (liams[j].status == 0 && i != j) {
				var dst = dist(liams[i].x,liams[i].y,liams[j].x,liams[j].y);
				liams[i].dPushx -= (liams[j].x-liams[i].x)/(dst*dst);
				liams[i].dPushy -= (liams[j].y-liams[i].y)/(dst*dst);
			}
		}
	}
	function grahamPush(i) {
		liams[i].dPushy=0;
		liams[i].dPushx=0;
		var j=0;
		var l = grahams.length;
		for(j=0; j<l; j++) {
			var dst = dist(liams[i].x,liams[i].y,grahams[j].x,grahams[j].y);
			if (dst <= 2*grahams[j].range) {
				liams[i].dPushx -= (grahams[j].x-liams[i].x)/(dst*dst);
				liams[i].dPushy -= (grahams[j].y-liams[i].y)/(dst*dst);
			}
		}
	}
	
	function circleOverlap(d,r1,r2) {
		var r=Math.min(r1,r2);
		var R=Math.max(r1,r2);
		if (d<=R-r) {
			return Math.PI*r*r;
		}
		else {
			return 	r*r*Math.acos((d*d+r*r-R*R)/(2*d*r))
					+R*R*Math.acos((d*d+R*R-r*r)/(2*d*R))
					-0.5*Math.sqrt((-d+r+R)*(d+r-R)*(d-r+R)*(d+r+R));
		}
	}
	
	function makeFridge(x,y) {
		// Only allow one fridge, always in center
		if (fridges.length > 0) return;

		// Place fridge in center of canvas
		var centerX = canvas.width / 2;
		var centerY = canvas.height / 2;

		fridges.push({x: centerX
					, y: centerY
					, milkOz: fridgeMilkOz
					, r:fridgeRadius
					, status: 1
					, output: 100});  // Fixed XP output
	}
	

	function liamGen() {
		if (liamsOn) {
			if (liamGenCount >= liamGenTimer && liamsOn) {
				makeLiam(Math.random()*canvas.width/10,Math.random()*canvas.height/10);
				liamGenCount=0;
			}
			liamGenCount++;
			liamGenTimer = Math.max(minLiamGen,initLiamGen-(Math.round(frameCounter/stepLiamGen)))
		}
	}

	function makeLiam(liamX,liamY,speedMultiplier) {
		liamLiveCount++;
		liamTotalCount++;
		if (speedMultiplier === undefined) speedMultiplier = 1;
		liams.push({x: liamX
				, y: liamY
				, dx: Math.random()*liamSpeed*speedMultiplier
				, dy: Math.random()*liamSpeed*speedMultiplier
				, dPushx: 0
				, dPushy: 0
				, status: 1
				, shotAt: 0
				, pStep: frameCounter%pathCalcStep
				, closestFridge: 0
				, closestFridgeDst: 0
				, speedMultiplier: speedMultiplier});  // Track speed multiplier
	}
	
	function makeGraham(grahamX,grahamY,railAX,railAY,railBX,railBY) {
		grahamCount++;
		grahams.push({x: grahamX
					, y: grahamY
					, dx: 0
					, dy: 0
					, AX: railAX
					, AY: railAY
					, BX: railBX
					, BY: railBY
					, optX: 0
					, optY: 0
					, range: grahamRange
					, reloadCounter: grahamReloadTime
					, reloadTime: grahamReloadTime
					, angle: 0  // Facing angle in radians
					, arcAngle: grahamFiringArc * Math.PI / 180  // Convert degrees to radians
					, id: grahamNextId++
					, kills: 0
					, xp: 0
					, caffeineLevel: 0  // Caffeine upgrade level
					});
	}
	
	function killLiam(lNo,status,grahamId) {
		liams[lNo].status = status;
		liams[lNo].dx = 0;
		liams[lNo].dy = 0;
		liamLiveCount--;

		// If killed by a Graham (grahamId provided), track kill and add XP
		if (grahamId !== undefined) {
			var g = grahams.find(function(graham) { return graham.id === grahamId; });
			if (g) {
				g.kills++;
				g.xp += 100;
				// Add floating "+100 XP" text
				floatingTexts.push({x: g.x, y: g.y - 20, text: "+100 XP", frame: 0, maxFrames: 60});
				// Add kill log
				killLog.unshift("Graham " + g.id + " stopped a Liam");
				if (killLog.length > 5) killLog.pop();  // Keep only last 5
			}
		}
	}

	function killPunch(pNo) {
		punches[pNo].status = 0;
		punches[pNo].dx = 0;
		punches[pNo].dy = 0;
		punchCount--;
	}
	function killWell(wNo) {
		wells[wNo].status = 0;
	}
		
	function dist(ax,ay,bx,by) {
	return Math.sqrt((ax-bx)*(ax-bx) + (ay-by)*(ay-by));
	}
	
    function liamPunchCD() {
		minLivePunch=0;
		var i=0;
		var j=0;
		var liamL =liams.length;
		var punchL =punches.length;
        for(i=0; i<punchL; i++) {
			if (punches[i].status ==1) {
				if (minLivePunch==0) {minLivePunch=i;}
				for(j=0; j<liamL; j++) {
					if (liams[j].status ==1) {
						if(punches[i].x+2*punchRadius > liams[j].x
						&& punches[i].x < liams[j].x+2*liamRadius
						&& punches[i].y+2*punchRadius > liams[j].y
						&& punches[i].y < liams[j].y+2*liamRadius) {
							// Check if it's corn - special effect!
							if (punches[i].veggie === 'ðŸŒ½') {
								// Corn makes Liam 1.5x faster
								liams[j].speedMultiplier *= 1.5;
								// Update velocity with new speed
								var mag = dist(0,0,liams[j].dx,liams[j].dy);
								if (mag > 0) {
									liams[j].dx *= 1.5;
									liams[j].dy *= 1.5;
								}
								killPunch(i);
							} else {
								// Normal veggies kill the Liam
								killLiam(j,0,punches[i].grahamId);  // Pass Graham ID for tracking
								killPunch(i);
							}
							break;
						}
					}
				}
			}
        }
    }
    function liamFridgeCD() {
		var i=0;
		var l =fridges.length;
        for(i=0; i<l; i++) {
			if (fridges[i].status ==1) {
				var j=0;
				var liamL = liams.length;
				for(j=0; j<liamL; j++) {
					if (liams[j].status ==1) {
						if(fridges[i].x+fridgeWidth > liams[j].x
						&& fridges[i].y+fridgeWidth > liams[j].y
						&& fridges[i].x < liams[j].x+2*liamRadius
						&& fridges[i].y < liams[j].y+2*liamRadius) {
							killLiam(j,2);  // No Graham ID - stopped by fridge
							fridges[i].milkOz -= 10;  // Each Liam drinks 10 oz of milk
							if(fridges[i].milkOz <= 0) {
								fridges[i].status =0;
							}
						}
					}
				}
			}
        }
    }
	
	function liamsInWedge(x,y,range,angle,arcAngle) {
		// Check if Liams are within wedge-shaped firing range
		var count = 0;
		var j=0;
		var l =liams.length;
		for(j=0; j<l; j++) {
			if (liams[j].status == 1)	{
				var d = dist(x,y,liams[j].x,liams[j].y);
				if (d <= range) {
					// Calculate angle to Liam
					var angleToLiam = Math.atan2(liams[j].y - y, liams[j].x - x);
					var angleDiff = Math.abs(angleToLiam - angle);
					// Normalize angle difference to [-PI, PI]
					while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
					while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
					angleDiff = Math.abs(angleDiff);
					if (angleDiff <= arcAngle / 2) {
						count++;
					}
				}
			}
		}
		return count;
	}

	function spawnPortal() {
		if (portals.length >= maxPortals) return;

		// Random position on canvas
		var x = Math.random() * canvas.width;
		var y = Math.random() * canvas.height;

		portals.push({
			x: x,
			y: y,
			r: portalRadius,
			status: 1
		});
	}

	function liamPortalCD() {
		// Check if Liams enter portals
		var i=0;
		var l = portals.length;
		for(i=0; i<l; i++) {
			if (portals[i].status == 1) {
				var j=0;
				var liamL = liams.length;
				for(j=0; j<liamL; j++) {
					if (liams[j].status == 1) {
						var d = dist(liams[j].x, liams[j].y, portals[i].x, portals[i].y);
						if (d <= portals[i].r) {
							// Liam entered portal! Clone it
							var angle1 = Math.random() * Math.PI * 2;
							var angle2 = Math.random() * Math.PI * 2;
							var speed = liamSpeed * liams[j].speedMultiplier;

							// Create two new Liams with random trajectories
							makeLiam(liams[j].x, liams[j].y, liams[j].speedMultiplier);
							liams[liams.length-1].dx = Math.cos(angle1) * speed;
							liams[liams.length-1].dy = Math.sin(angle1) * speed;

							makeLiam(liams[j].x, liams[j].y, liams[j].speedMultiplier);
							liams[liams.length-1].dx = Math.cos(angle2) * speed;
							liams[liams.length-1].dy = Math.sin(angle2) * speed;

							// Kill the original Liam (it split into two)
							killLiam(j, 0);

							// Remove the portal after use
							portals[i].status = 0;
							break;
						}
					}
				}
			}
		}

		// Clean up dead portals
		portals = portals.filter(function(p) { return p.status == 1; });
	}
	
    function posGrahams() {
		var i=0;
		var l = grahamCount;
        for(i=0; i<l; i++) {
			var g = grahams[i];
            if (g.AX > 0 && g.dx == 0 && g.dy == 0) { // if rail exists and Graham is not already moving
				var railLen = dist(g.AX,g.AY,g.BX,g.BY);
				var maxLiams = 0;
				var optP = [];
				var pXY = [];
				var pMax = Math.max(Math.round(railLen/grahamGranularity),1);
				var pLiams = 0;
				var p =0;
				for(p=0; p < pMax; p++) {
					pXY[0] = g.AX + p * (g.BX - g.AX)/pMax;
					pXY[1] = g.AY + p * (g.BY - g.AY)/pMax;
					pLiams = liamsInWedge(pXY[0], pXY[1], g.range, g.angle, g.arcAngle)
					if (pLiams > maxLiams) {
						optP[0] = pXY[0];
						optP[1] = pXY[1];
						maxLiams=pLiams;
					}
				}
				if (maxLiams > grahamSeekAggro*liamsInWedge(g.x, g.y, g.range, g.angle, g.arcAngle)) {
					g.optX = optP[0];
					g.optY = optP[1];
					g.dx = g.optX - g.x;
					g.dy = g.optY - g.y;
					if (g.dx != 0 || g.dy != 0) {
						var mag = dist(0,0,g.dx,g.dy);
						g.dx *= grahamSpeed/mag;
						g.dy *= grahamSpeed/mag;
					}
				}
			}
        }
    }
	
	
	function randomTerrain () {
		var rando = 0;
		var up = 1;
		terrainX = (canvas.width/terrainRes)+1;
		terrainY = (canvas.height/terrainRes)+1;
        for(x=0; x<terrainX; x++) {
			terrain[x]=[];
			for(y=0; y<terrainY; y++) {
				terrain[x][y] = 1;
			}
        }
        for(y=1; y<terrainY; y++) {
			for(x=1; x<terrainX; x++) {
				up = Math.sign(terrain[x][y-1] - terrain[x-1][y-1]);//+ Math.sign(terrain[x-1][y] - terrain[x-2][y]);
				rando = up*(Math.random()-trendStrength);
				terrain[x][y] = Math.max(0,(terrain[x-1][y]+terrain[x-1][y-1]+terrain[x-1][y]+terrain[x-1][y+1])/4+rando);
				if (terrain[x][y]>maxE) {
					maxE = terrain[x][y];
				}
			}
        }
	}
	function drawTerrain () {
		var r = 0;
		var g = 0;
        for(y=0; y<terrainY; y++) {
			for(x=0; x<terrainX; x++) {
				r=Math.min(256,Math.round(512*(terrain[x][y]/maxE)));
				g=Math.min(256,Math.round(512*(1-(terrain[x][y]/maxE))));
				//ctx.beginPath();
				//ctx.rect(x*terrainRes, y*terrainRes, terrainRes, terrainRes);
				////ctx.fillStyle = "rgba("+r+","+g+",150,0)";
				//ctx.fillStyle = "rgba(151,183,64,0)";
				//ctx.fill();
				//ctx.closePath();
				ctx.font = "10px Arial";
				ctx.fillStyle = "rgba("+r+","+g+",0,1)";
				ctx.fillText("x", x*terrainRes, y*terrainRes);
			}
        }
	
    //ctx.fillStyle = "#F9A520";
    //ctx.moveTo(0, 0); // start at top left corner of canvas
    //ctx.lineTo(200, 0); // go 200px to right (x), straight line from 0 to 0
    //ctx.lineTo(100, 200); // go to horizontal 100 (x) and vertical 200 (y)
    //ctx.fill(); // connect and fill
	}
	
    function grahamPunch() {
		var range = 0;
		var i=0;
		var gL =grahams.length;
        for(i=0; i<gL; i++) {
			// Calculate effective reload time based on caffeine level
			var effectiveReloadTime = Math.max(1, grahams[i].reloadTime - grahams[i].caffeineLevel);

            if (grahams[i].reloadCounter < effectiveReloadTime) {
				grahams[i].reloadCounter++;
			}
			else {
				var j = 0;
				var liamL = liams.length;
				for(j=0; j<liamL; j++) {
					if (liams[j].status == 1 && liams[j].shotAt <= 0)	{
						range = dist(grahams[i].x,grahams[i].y,liams[j].x,liams[j].y)
						if (range <= grahams[i].range) {
							// Check if Liam is within wedge
							var angleToLiam = Math.atan2(liams[j].y - grahams[i].y, liams[j].x - grahams[i].x);
							var angleDiff = Math.abs(angleToLiam - grahams[i].angle);
							while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
							while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
							angleDiff = Math.abs(angleDiff);

							if (angleDiff <= grahams[i].arcAngle / 2) {
								throwPunch(i,j,punchSpeed);
								grahams[i].reloadCounter=0;
								break;
							}
						}
					}
				}
			}
        }
    }
	
	function throwPunch(i,j,speed) {
		// Takes Graham #i and Liam #j, calculates a veggie trajectory
		var jx = liams[j].x;
		var jy = liams[j].y;
		var t =0;
		var n=0;
		for(n=0; n<fireLoops; n++) {
            t=dist(grahams[i].x,grahams[i].y,jx,jy)/speed
			jx=liams[j].x+t*liams[j].dx;
			jy=liams[j].y+t*liams[j].dy;
        }
		var idx = jx-grahams[i].x;
		var idy = jy-grahams[i].y;
		var mag = dist(0,0,idx,idy);
		idx *= speed/mag;
		idy *= speed/mag;

		punchCount++;
		// Pick a random veggie sprite
		var randomVeggie = veggieSprites[Math.floor(Math.random() * veggieSprites.length)];
		punches.push({
			x: grahams[i].x,
			y: grahams[i].y,
			dx: idx,
			dy: idy,
			status:1,
			grahamId: grahams[i].id,  // Track which Graham threw this veggie
			veggie: randomVeggie,  // Random veggie sprite
			rotation: Math.random() * Math.PI * 2  // Random initial rotation
		});
		liams[j].shotAt = t+1;
	}
		
    function drawGrahams() {
		var i=0;
		var l =grahams.length;
        if (gPlace||kShift) {
			for(i=0; i<l; i++) {
				// Draw wedge-shaped range
				ctx.beginPath();
				ctx.moveTo(grahams[i].x, grahams[i].y);
				ctx.arc(grahams[i].x, grahams[i].y, grahams[i].range,
					grahams[i].angle - grahams[i].arcAngle/2,
					grahams[i].angle + grahams[i].arcAngle/2);
				ctx.lineTo(grahams[i].x, grahams[i].y);
				ctx.strokeStyle = "rgba(200,0,0,.25)";
				ctx.fillStyle = "rgba(200,0,0,.1)";
				ctx.fill();
				ctx.stroke();
			}
		}
        for(i=0; i<l; i++) {
			// Draw Graham body
			ctx.beginPath();
			ctx.rect(grahams[i].x-0.5*grahamWidth, grahams[i].y-0.5*grahamWidth, grahamWidth, grahamWidth);
			ctx.fillStyle = selectedGraham === i ? "#FF0000" : "#454545";
			ctx.fill();
			ctx.closePath();

			// Draw facing direction indicator
			var indicatorLen = 20;
			ctx.beginPath();
			ctx.moveTo(grahams[i].x, grahams[i].y);
			ctx.lineTo(grahams[i].x + Math.cos(grahams[i].angle) * indicatorLen,
			           grahams[i].y + Math.sin(grahams[i].angle) * indicatorLen);
			ctx.strokeStyle = "#FF0000";
			ctx.lineWidth = 2;
			ctx.stroke();

			// Draw rail if exists
			if (grahams[i].AX > 0) {
				ctx.beginPath();
				ctx.moveTo(grahams[i].AX,grahams[i].AY);
				ctx.lineTo(grahams[i].BX,grahams[i].BY);
				ctx.lineWidth = railWidth;
				ctx.strokeStyle = "#454545";
				ctx.stroke();
			}

			// Draw Graham label with stats
			ctx.font = "11px Arial";
			ctx.fillStyle = "#000000";
			ctx.fillText("Graham " + grahams[i].id, grahams[i].x - 25, grahams[i].y - 28);
			ctx.fillText("Kills: " + grahams[i].kills, grahams[i].x - 22, grahams[i].y - 17);
			ctx.fillText("XP: " + grahams[i].xp, grahams[i].x - 15, grahams[i].y - 6);
			if (grahams[i].caffeineLevel > 0) {
				ctx.fillStyle = "#FF6600";
				ctx.fillText("â˜•Ã—" + grahams[i].caffeineLevel, grahams[i].x + 18, grahams[i].y - 6);
			}

        }
		if (gPlace) {
			drawGrahamProspect();
		}
    }
    function drawGrahamProspect() {
		var color = "#FF0000";
		var cost = costEstimate();
		if (xp>=cost && nearDist>=elbowRoom) {
			color = "#00FF00";
		}

		// Draw wedge preview
		ctx.beginPath();
		ctx.moveTo(currentPos[0], currentPos[1]);
		ctx.arc(currentPos[0],currentPos[1], grahamRange, -grahamFiringArc*Math.PI/360, grahamFiringArc*Math.PI/360);
		ctx.lineTo(currentPos[0], currentPos[1]);
		ctx.strokeStyle = color;
		ctx.stroke();

		ctx.beginPath();
		ctx.rect(currentPos[0]-0.5*grahamWidth, currentPos[1]-0.5*grahamWidth, grahamWidth, grahamWidth);
		ctx.fillStyle = color;
		ctx.fill();
		ctx.closePath();

		ctx.font = "16px Arial";
		ctx.fillStyle = color;
		ctx.fillText(Math.ceil(cost)+" XP",currentPos[0]+15,currentPos[1]+5);
	}
	
	function drawFridgeProspect() {
		var color = "#FF0000";
		var cost = costEstimate();
		if (xp>=cost && nearDist>=elbowRoom) {
			color = "#00FF00";
		}
		ctx.beginPath();
		ctx.rect(currentPos[0]-fridgeWidth/2,currentPos[1]-fridgeWidth/2, fridgeWidth, fridgeWidth);
		ctx.fillStyle = color;
		ctx.fill();
		ctx.closePath();

		ctx.beginPath();
		ctx.arc(currentPos[0],currentPos[1], fridgeRadius, 0, Math.PI*2);
		ctx.strokeStyle = color;
		ctx.stroke();

		ctx.font = "16px Arial";
		ctx.fillStyle = color;
		ctx.fillText(Math.ceil(cost)+" XP",currentPos[0]+30,currentPos[1]+5);

	}

	function costEstimate() {
		var buildingCost =0;
		if (gPlace) {buildingCost = grahamCost;}
		// No fridge cost - fridge is auto-created in center
		findNearBuilding();
		return buildingCost;  // No pipe costs anymore
	}
	
	function findNearBuilding() {

		var i=0;
		var x = currentPos[0];
		var y = currentPos[1];
		nearBuildingX = currentPos[0];
		nearBuildingY = currentPos[1];
		nearDist = 0;

		var l =fridges.length;
		if (l>0) {
			nearBuildingX = fridges[0].x;
			nearBuildingY = fridges[0].y;
			nearDist = dist(x,y,fridges[0].x,fridges[0].y);
			for(i=1; i<l; i++) {
				if (fridges[i].status ==1 && dist(x,y,fridges[i].x,fridges[i].y)<nearDist) {
					nearBuildingX = fridges[i].x;
					nearBuildingY = fridges[i].y;
					nearDist = dist(x,y,fridges[i].x,fridges[i].y);

				}
			}
			l =grahams.length;
			for(i=0; i<l; i++) {
				if (dist(x,y,grahams[i].x,grahams[i].y)<nearDist) {
					nearBuildingX = grahams[i].x;
					nearBuildingY = grahams[i].y;
					nearDist = dist(x,y,grahams[i].x,grahams[i].y);

				}
			}
		}

	}
		
    function drawFridges() {
		var i=0;

		var l =fridges.length;
        for(i=0; i<l; i++) {
			if (fridges[i].status ==1) {
				// Draw fridge body
				ctx.beginPath();
				ctx.rect(fridges[i].x-fridgeWidth/2, fridges[i].y-fridgeWidth/2, fridgeWidth, fridgeWidth);
				ctx.fillStyle = "#FFFFFF";
				ctx.strokeStyle = "#666666";
				ctx.lineWidth = 2;
				ctx.fill();
				ctx.stroke();
				ctx.closePath();

				// Draw milk emojis based on milk oz
				var milkCartons = Math.ceil(fridges[i].milkOz / milkPerEmoji);
				ctx.font = "20px Arial";
				var emojisPerRow = 5;
				var emojiSpacing = 22;
				for(var m=0; m<milkCartons; m++) {
					var row = Math.floor(m / emojisPerRow);
					var col = m % emojisPerRow;
					var emojiX = fridges[i].x - 50 + col * emojiSpacing;
					var emojiY = fridges[i].y + 40 + row * emojiSpacing;
					ctx.fillText("ðŸ¥›", emojiX, emojiY);
				}

				// Draw detection radius
				ctx.beginPath();
				ctx.arc(fridges[i].x, fridges[i].y, fridges[i].r, 0, Math.PI*2);
				ctx.strokeStyle = "#DDDDDD";
				ctx.lineWidth = 1;
				ctx.stroke();

				// Display milk oz
				ctx.font = "14px Arial";
				ctx.fillStyle = "#0000FF";
				ctx.fillText(fridges[i].milkOz + " oz", fridges[i].x - 20, fridges[i].y - 30);
			}
		}
		// No fridge placement - only one fridge in center
    }
	
    function drawScore() {
        ctx.font = "16px Arial";
        ctx.fillStyle = "#000000";
        ctx.fillText("Score: "+score, 8, 20);
        if (fridges.length > 0 && fridges[0].status == 1) {
			ctx.fillText("Milk: "+fridges[0].milkOz+" oz ðŸ¥›", 8, 40);
		} else {
			ctx.fillText("Milk: OUT!", 8, 40);
		}
        ctx.fillText("Grahams: "+grahams.length, 8, 60);
        ctx.fillText("XP: "+Math.round(xp), 8, 80);
		ctx.fillText(Math.round(10000/(timr[9]-timr[0])) +"fps", 8, 100);

        ctx.fillText("Press SPACEBAR to pause", canvas.width-300, 20);
        ctx.fillText("Press G to place a Graham", canvas.width-300, 40);
        ctx.fillText("Click Graham to select", canvas.width-300, 60);
		ctx.fillText("Arrows to rotate Graham", canvas.width-300, 80);
		ctx.fillText("C to upgrade caffeine (XP)", canvas.width-300, 100);
		ctx.fillText("ðŸŒ½ = Speed boost!", canvas.width-300, 120);

		// Draw kill log
		ctx.font = "14px Arial";
		ctx.fillStyle = "#006600";
		for(var i=0; i<killLog.length; i++) {
			ctx.fillText(killLog[i], canvas.width-300, 160 + i*18);
		}
    }

	function drawFloatingTexts() {
		var i = floatingTexts.length;
		while(i--) {
			var ft = floatingTexts[i];
			if (ft.frame < ft.maxFrames) {
				ctx.font = "bold 14px Arial";
				ctx.fillStyle = "#00AA00";
				var yOffset = -ft.frame * 0.5;  // Float upward
				var alpha = 1 - (ft.frame / ft.maxFrames);
				ctx.globalAlpha = alpha;
				ctx.fillText(ft.text, ft.x + 10, ft.y + yOffset);
				ctx.globalAlpha = 1;
				ft.frame++;
			} else {
				floatingTexts.splice(i, 1);
			}
		}
	}
	
    function drawPortals() {
		var i=0;
		var l = portals.length;
		for(i=0; i<l; i++) {
			if (portals[i].status == 1) {
				// Draw portal as swirling purple circle
				ctx.beginPath();
				ctx.arc(portals[i].x, portals[i].y, portals[i].r, 0, Math.PI*2);
				ctx.fillStyle = "rgba(138, 43, 226, 0.3)";  // Semi-transparent purple
				ctx.fill();
				ctx.strokeStyle = "#8B00FF";
				ctx.lineWidth = 3;
				ctx.stroke();
				ctx.closePath();

				// Add portal label
				ctx.font = "14px Arial";
				ctx.fillStyle = "#8B00FF";
				ctx.fillText("CLONE", portals[i].x - 25, portals[i].y);
			}
		}
	}

    function drawLiams() {
		var i=0;
		var l =liams.length;
        for(i=0; i<l; i++) {
			if (liams[i].status ==1) {
				ctx.beginPath();
				ctx.arc(liams[i].x, liams[i].y, liamRadius, 0, Math.PI*2);
				// Color based on speed multiplier
				if (liams[i].speedMultiplier > 1) {
					ctx.fillStyle = "#FF0000";  // Red for fast Liams
				} else {
					ctx.fillStyle = "#0095DD";  // Blue for normal Liams
				}
				ctx.fill();
				ctx.closePath();
			}
        }
    }

    function drawPunches() {
		var i=0;
		var l =punches.length;
        for(i=0; i<l; i++) {
			if (punches[i].status ==1) {
				// Draw veggie sprite
				ctx.save();
				ctx.translate(punches[i].x, punches[i].y);
				// Add spinning rotation
				punches[i].rotation += 0.1;
				ctx.rotate(punches[i].rotation);
				ctx.font = veggieSize + "px Arial";
				ctx.textAlign = "center";
				ctx.textBaseline = "middle";
				ctx.fillText(punches[i].veggie, 0, 0);
				ctx.restore();
			}
        }
    }	
    function liamCrawl() {
		minLiveLiam = 0;
		var i=0;
		var l = liams.length;
        for(i=0; i<l; i++) {
			if (liams[i].status ==1) {
				if (minLiveLiam==0) {minLiveLiam=i;}
				liams[i].x += liams[i].dx;
				liams[i].y += liams[i].dy;

				if (liams[i].pStep == frameCounter%pathCalcStep) {
					deathPush(i);
					//grahamPush(i);
					fridgePull(i);
					var pullMod = Math.max(1,ovr1Range/liams[i].closestFridgeDst);
					var magPush = dist(0,0,liams[i].dPushx,liams[i].dPushy);
					var magPull = dist(0,0,liams[i].wPullx,liams[i].wPully);
					if (magPush>0) {
						if (magPull/magPush <= minPullPushRatio) {pullMod *= minPullPushRatio * magPush/magPull;}
						liams[i].wPullx *= pullMod;
						liams[i].wPully *= pullMod;
					}
					liams[i].dx = liams[i].dPushx + liams[i].wPullx;
					liams[i].dy = liams[i].dPushy + liams[i].wPully;
					var mag = dist(0,0,liams[i].dx,liams[i].dy);
					if (mag > 0){
						// Use speed multiplier for the Liam's speed
						var currentSpeed = liamSpeed * liams[i].speedMultiplier;
						liams[i].dx*=(currentSpeed/mag);
						liams[i].dy*=(currentSpeed/mag);
					}
				}

				if (liams[i].shotAt>0) {liams[i].shotAt-=1};

			}
        }
    }
	function liamPunchCleanup() {
		liams.splice(0,Math.max(0,minLiveLiam-(deadLiamBuffer-(liams.length-minLiveLiam-liamLiveCount))));
		punches.splice(0,Math.max(0,minLivePunch-7));
	}
    function grahamSlide() {
		var i =0;
		var l = grahams.length;
        for(i=0; i<l; i++) {
			var g = grahams[i];
			if (g.dx!=0 || g.dy!=0) { // if Graham moving
				if (dist(g.optX,g.optY,g.x,g.y) < grahamSpeed) { // if Graham will reach/pass destination on next frame
					g.x = g.optX;	// put Graham in destination
					g.y = g.optY;
					g.dx = 0;
					g.dy = 0;
				}
				else {
					g.x += g.dx;
					g.y += g.dy;
				}
			}
        }
    }
    function punchFly() {
		var i =0;
		var l = punches.length;
        for(i=0; i<l; i++) {
			if (punches[i].status == 1){
				punches[i].x+=punches[i].dx;
				punches[i].y+=punches[i].dy;
				if(punches[i].x + punches[i].dx > canvas.width - punchRadius
				|| punches[i].x + punches[i].dx < punchRadius
				|| punches[i].y + punches[i].dy < punchRadius
				|| punches[i].y + punches[i].dy > canvas.height - punchRadius) {
					killPunch(i);
				}
			}
        }
	}
	function counters() {
		timr.push(Date.now());
		timr.shift();
		frameCounter++;

		// Portal spawning
		portalSpawnCounter++;
		if (portalSpawnCounter >= portalSpawnRate) {
			spawnPortal();
			portalSpawnCounter = 0;
		}

		var j=0;
		var l = fridges.length;
		if (l >= 1) {
			liamsOn=true;
		}
		var totalMilk = 0;
		for(j=0; j<l; j++) {
			var f = fridges[j];
			if (f.status==1) {
				xp+=f.output*0.01;  // Fixed XP generation rate
				totalMilk+=Math.max(0,f.milkOz)
			}
		}
		if (l>0 && totalMilk == 0) {
			alert("YOU LOSE. THE FRIDGE IS OUT OF MILK! "+ liams.length +" LIAMS DRANK IT ALL!");
			initialize();
		}
	}
	function initialize() {
		score = 0;
		liams = [];
		minLiveLiam = 0;
		liamTotalCount = 0;
		liamLiveCount = 0;
		liamGenCount = 100;
		liamGenTimer = 0;
		liamsOn = false;
		punches = [];
		punchCount = 0;
		fridges = [];  // Renamed from wells
		grahams = [];
		grahamCount = 0;
		grahamNextId = 1;
		frameCounter = 0;
		timr = [0,0,0,0,0,0,0,0,0,0];
		xp = 900;  // Start with enough for 3 Grahams
		proposedCost = 0;
		currentPos = [];
		minLivePunch = 0;
		kShift = false;
		gPlace = false;
		wPlace = false;  // Don't start in well placement mode
		isDragging = false;
		dragDist = 0;
		startingPos = [];
		clickDown=false;
		valid = false;
		paused = false;
		selectedGraham = -1;
		floatingTexts = [];
		killLog = [];
		portals = [];
		portalSpawnCounter = 0;

		// Create the one and only fridge in the center
		makeFridge(0, 0);  // Position doesn't matter, it will be centered
	}
	//function roundRect(x, y, width, height, radius, fill, stroke) {
	//	if (typeof stroke == "undefined" ) {
	//		stroke = true;
	//	}
	//	if (typeof radius === "undefined") {
	//		radius = 5;
	//	}
	//	ctx.beginPath();
	//	ctx.moveTo(x + radius, y);
	//	ctx.lineTo(x + width - radius, y);
	//	ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
	//	ctx.lineTo(x + width, y + height - radius);
	//	ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
	//	ctx.lineTo(x + radius, y + height);
	//	ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
	//	ctx.lineTo(x, y + radius);
	//	ctx.quadraticCurveTo(x, y, x + radius, y);
	//	ctx.closePath();
	//	if (stroke) {
	//		ctx.stroke();
	//	}
	//	if (fill) {
	//		ctx.fill();
	//	}        
	//}
	//
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
		//drawTerrain();
		drawPortals();
		drawGrahams();
		drawFridges();
		drawLiams();
        drawPunches();
		drawFloatingTexts();
        drawScore();
		if (!paused) {
			liamGen();

			liamCrawl();
			posGrahams();
			grahamSlide();
			grahamPunch();
			punchFly();

			liamPunchCD();
			liamFridgeCD();
			liamPortalCD();  // Check portal collisions

			liamPunchCleanup();
			counters();
		} else {
			ctx.font = "100px Arial";
			ctx.fillStyle = "#0095DD";
			ctx.fillText("\u{23F8}", canvas.width/2, canvas.height/2);
		}
        requestAnimationFrame(draw);
    }

	//randomTerrain();
	initialize();
	draw();
</script>

</body>
</html>